{"ast":null,"code":"/**\n * dd-draggable.ts 10.3.1\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\nimport { DDManager } from './dd-manager';\nimport { Utils } from './utils';\nimport { DDBaseImplement } from './dd-base-impl';\nimport { isTouch, touchend, touchmove, touchstart, pointerdown } from './dd-touch';\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n// let count = 0; // TEST\nclass DDDraggable extends DDBaseImplement {\n  constructor(el, option = {}) {\n    super();\n    this.el = el;\n    this.option = option;\n    /** @internal */\n    this.dragTransform = {\n      xScale: 1,\n      yScale: 1,\n      xOffset: 0,\n      yOffset: 0\n    };\n    // get the element that is actually supposed to be dragged by\n    const handleName = option.handle.substring(1);\n    const n = el.gridstackNode;\n    this.dragEls = el.classList.contains(handleName) ? [el] : n?.subGrid ? [el.querySelector(option.handle) || el] : Array.from(el.querySelectorAll(option.handle));\n    if (this.dragEls.length === 0) {\n      this.dragEls = [el];\n    }\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._keyEvent = this._keyEvent.bind(this);\n    this.enable();\n  }\n  on(event, callback) {\n    super.on(event, callback);\n  }\n  off(event) {\n    super.off(event);\n  }\n  enable() {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.addEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.addEventListener('touchstart', touchstart);\n        dragEl.addEventListener('pointerdown', pointerdown);\n        // dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n      }\n    });\n    this.el.classList.remove('ui-draggable-disabled');\n  }\n  disable(forDestroy = false) {\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.removeEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.removeEventListener('touchstart', touchstart);\n        dragEl.removeEventListener('pointerdown', pointerdown);\n      }\n    });\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n  destroy() {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.mouseDownEvent) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n  updateOption(opts) {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n  /** @internal call when mouse goes down before a dragstart happens */\n  _mouseDown(e) {\n    // don't let more than one widget handle mouseStart\n    if (DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n    // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n    if (!this.dragEls.find(el => el === e.target) && e.target.closest(skipMouseDown)) return true;\n    if (this.option.cancel) {\n      if (e.target.closest(this.option.cancel)) return true;\n    }\n    // REMOVE: why would we get the event if it wasn't for us or child ?\n    // make sure we are clicking on a drag handle or child of it...\n    // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n    // let className = this.option.handle.substring(1);\n    // let el = e.target as HTMLElement;\n    // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n    // if (!el) return;\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, {\n      capture: true,\n      passive: true\n    }); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      e.target.addEventListener('touchmove', touchmove);\n      e.target.addEventListener('touchend', touchend);\n    }\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if (document.activeElement) document.activeElement.blur();\n    DDManager.mouseHandled = true;\n    return true;\n  }\n  /** @internal method to call actual drag event */\n  _callDrag(e) {\n    if (!this.dragging) return;\n    const ev = Utils.initEvent(e, {\n      target: this.el,\n      type: 'drag'\n    });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  _mouseMove(e) {\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    let s = this.mouseDownEvent;\n    this.lastDrag = e;\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (DDManager.pauseDrag) {\n        const pause = Number.isInteger(DDManager.pauseDrag) ? DDManager.pauseDrag : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\n       * don't start unless we've moved at least 3 pixels\n       */\n      this.dragging = true;\n      DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      let grid = this.el.gridstackNode?.grid;\n      if (grid) {\n        DDManager.dropElement = grid.el.ddElement.ddDroppable;\n      } else {\n        delete DDManager.dropElement;\n      }\n      this.helper = this._createHelper(e);\n      this._setupHelperContainmentStyle();\n      this.dragTransform = Utils.getValuesFromTransformedElement(this.helperContainment);\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      this._setupHelperStyle(e);\n      const ev = Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstart'\n      });\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n      // now track keyboard events to cancel or rotate\n      document.addEventListener('keydown', this._keyEvent);\n    }\n    // e.preventDefault(); // passive = true. OLD: was needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n  /** @internal call when the mouse gets released to drop the item at current location */\n  _mouseUp(e) {\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      e.target.removeEventListener('touchmove', touchmove, true);\n      e.target.removeEventListener('touchend', touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n      delete this.el.gridstackNode?._origRotate;\n      document.removeEventListener('keydown', this._keyEvent);\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (DDManager.dropElement?.el === this.el.parentElement) {\n        delete DDManager.dropElement;\n      }\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n      const ev = Utils.initEvent(e, {\n        target: this.el,\n        type: 'dragstop'\n      });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n      this.triggerEvent('dragstop', ev);\n      // call the droppable method to receive the item\n      if (DDManager.dropElement) {\n        DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    delete DDManager.mouseHandled;\n    e.preventDefault();\n  }\n  /** @internal call when keys are being pressed - use Esc to cancel, R to rotate */\n  _keyEvent(e) {\n    const n = this.el.gridstackNode;\n    if (!n?.grid) return;\n    const grid = n.grid;\n    if (e.key === 'Escape') {\n      if (n._origRotate) {\n        n._orig = n._origRotate;\n        delete n._origRotate;\n      }\n      grid.engine.restoreInitial();\n      this._mouseUp(this.mouseDownEvent);\n    } else if (e.key === 'r' || e.key === 'R') {\n      if (!Utils.canBeRotated(n)) return;\n      n._origRotate = n._origRotate || {\n        ...n._orig\n      }; // store the real orig size in case we Esc after doing rotation\n      delete n._moving; // force rotate to happen (move waits for >50% coverage otherwise)\n      grid.setAnimation(false) // immediate rotate so _getDragOffset() gets the right dom size below\n      .rotate(n.el, {\n        top: -this.dragOffset.offsetTop,\n        left: -this.dragOffset.offsetLeft\n      }).setAnimation();\n      n._moving = true;\n      this.dragOffset = this._getDragOffset(this.lastDrag, n.el, this.helperContainment);\n      this.helper.style.width = this.dragOffset.width + 'px';\n      this.helper.style.height = this.dragOffset.height + 'px';\n      Utils.swap(n._orig, 'w', 'h');\n      delete n._rect;\n      this._mouseMove(this.lastDrag);\n    }\n  }\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  _createHelper(event) {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = Utils.cloneNode(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentElement : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n  /** @internal set the fix position of the dragged item */\n  _setupHelperStyle(e) {\n    this.helper.classList.add('ui-draggable-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n  /** @internal restore back the original style before dragging */\n  _removeHelperStyle() {\n    this.helper.classList.remove('ui-draggable-dragging');\n    let node = this.helper?.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n      let helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      let transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n  /** @internal updates the top/left position to follow the mouse */\n  _dragFollow(e) {\n    let containmentRect = {\n      left: 0,\n      top: 0\n    };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = (e.clientX + offset.offsetLeft - containmentRect.left) * this.dragTransform.xScale + 'px';\n    style.top = (e.clientY + offset.offsetTop - containmentRect.top) * this.dragTransform.yScale + 'px';\n  }\n  /** @internal */\n  _setupHelperContainmentStyle() {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n  /** @internal */\n  _getDragOffset(event, el, parent) {\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      xformOffsetX = this.dragTransform.xOffset;\n      xformOffsetY = this.dragTransform.yOffset;\n    }\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: -event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: -event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width * this.dragTransform.xScale,\n      height: targetOffset.height * this.dragTransform.yScale\n    };\n  }\n  /** @internal TODO: set to public as called by DDDroppable! */\n  ui() {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: {\n        top: (offset.top - containmentRect.top) * this.dragTransform.yScale,\n        left: (offset.left - containmentRect.left) * this.dragTransform.xScale\n      }\n      /* not used by GridStack for now...\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\n      */\n    };\n  }\n}\n/** @internal properties we change during dragging, and restore back */\nDDDraggable.originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];\nexport { DDDraggable };","map":{"version":3,"names":["DDManager","Utils","DDBaseImplement","isTouch","touchend","touchmove","touchstart","pointerdown","skipMouseDown","DDDraggable","constructor","el","option","dragTransform","xScale","yScale","xOffset","yOffset","handleName","handle","substring","n","gridstackNode","dragEls","classList","contains","subGrid","querySelector","Array","from","querySelectorAll","length","_mouseDown","bind","_mouseMove","_mouseUp","_keyEvent","enable","on","event","callback","off","disabled","forEach","dragEl","addEventListener","remove","disable","forDestroy","removeEventListener","add","destroy","dragTimeout","window","clearTimeout","mouseDownEvent","helper","updateOption","opts","Object","keys","key","e","mouseHandled","button","find","target","closest","cancel","dragging","dragElement","dropElement","document","capture","passive","preventDefault","activeElement","blur","_callDrag","ev","initEvent","type","drag","ui","triggerEvent","s","lastDrag","_dragFollow","pauseDrag","pause","Number","isInteger","setTimeout","Math","abs","x","y","grid","ddElement","ddDroppable","_createHelper","_setupHelperContainmentStyle","getValuesFromTransformedElement","helperContainment","dragOffset","_getDragOffset","_setupHelperStyle","start","_origRotate","parentElement","style","position","parentOriginStylePosition","_removeHelperStyle","stop","drop","_orig","engine","restoreInitial","canBeRotated","_moving","setAnimation","rotate","top","offsetTop","left","offsetLeft","width","height","swap","_rect","cloneNode","body","appendTo","dragElementOriginStyle","originStyleProp","map","prop","pointerEvents","willChange","transition","node","_isAboutToRemove","containmentRect","offset","clientX","clientY","getComputedStyle","match","parent","xformOffsetX","xformOffsetY","targetOffset","getBoundingClientRect","containmentEl"],"sources":["../src/dd-draggable.ts"],"sourcesContent":["/**\n * dd-draggable.ts 10.3.1\n * Copyright (c) 2021-2022 Alain Dumesny - see GridStack root license\n */\n\nimport { DDManager } from './dd-manager';\nimport { DragTransform, Utils } from './utils';\nimport { DDBaseImplement, HTMLElementExtendOpt } from './dd-base-impl';\nimport { GridItemHTMLElement, DDUIData, GridStackNode, GridStackPosition } from './types';\nimport { DDElementHost } from './dd-element';\nimport { isTouch, touchend, touchmove, touchstart, pointerdown } from './dd-touch';\n\n// TODO: merge with DDDragOpt ?\nexport interface DDDraggableOpt {\n  appendTo?: string | HTMLElement;\n  handle?: string;\n  helper?: 'clone' | HTMLElement | ((event: Event) => HTMLElement);\n  cancel?: string;\n  // containment?: string | HTMLElement; // TODO: not implemented yet\n  // revert?: string | boolean | unknown; // TODO: not implemented yet\n  // scroll?: boolean;\n  start?: (event: Event, ui: DDUIData) => void;\n  stop?: (event: Event) => void;\n  drag?: (event: Event, ui: DDUIData) => void;\n}\n\ninterface DragOffset {\n  left: number;\n  top: number;\n  width: number;\n  height: number;\n  offsetLeft: number;\n  offsetTop: number;\n}\n\ninterface GridStackNodeRotate extends GridStackNode {\n  _origRotate?: GridStackPosition;\n}\n\ntype DDDragEvent = 'drag' | 'dragstart' | 'dragstop';\n\n// make sure we are not clicking on known object that handles mouseDown\nconst skipMouseDown = 'input,textarea,button,select,option,[contenteditable=\"true\"],.ui-resizable-handle';\n\n// let count = 0; // TEST\n\nexport class DDDraggable extends DDBaseImplement implements HTMLElementExtendOpt<DDDraggableOpt> {\n  public helper: HTMLElement; // used by GridStackDDNative\n\n  /** @internal */\n  protected mouseDownEvent: MouseEvent;\n  /** @internal */\n  protected dragOffset: DragOffset;\n  /** @internal */\n  protected dragElementOriginStyle: Array<string>;\n  /** @internal */\n  protected dragEls: HTMLElement[];\n  /** @internal true while we are dragging an item around */\n  protected dragging: boolean;\n  /** @internal last drag event */\n  protected lastDrag: DragEvent;\n  /** @internal */\n  protected parentOriginStylePosition: string;\n  /** @internal */\n  protected helperContainment: HTMLElement;\n  /** @internal properties we change during dragging, and restore back */\n  protected static originStyleProp = ['transition', 'pointerEvents', 'position', 'left', 'top', 'minWidth', 'willChange'];\n  /** @internal pause before we call the actual drag hit collision code */\n  protected dragTimeout: number;\n  /** @internal */\n  protected dragTransform: DragTransform = {\n    xScale: 1,\n    yScale: 1,\n    xOffset: 0,\n    yOffset: 0\n  };\n\n  constructor(public el: GridItemHTMLElement, public option: DDDraggableOpt = {}) {\n    super();\n\n    // get the element that is actually supposed to be dragged by\n    const handleName = option.handle.substring(1);\n    const n = el.gridstackNode;\n    this.dragEls = el.classList.contains(handleName) ? [el] : (n?.subGrid ? [el.querySelector(option.handle) || el] : Array.from(el.querySelectorAll(option.handle)));\n    if (this.dragEls.length === 0) {\n      this.dragEls = [el];\n    }\n    // create var event binding so we can easily remove and still look like TS methods (unlike anonymous functions)\n    this._mouseDown = this._mouseDown.bind(this);\n    this._mouseMove = this._mouseMove.bind(this);\n    this._mouseUp = this._mouseUp.bind(this);\n    this._keyEvent = this._keyEvent.bind(this);\n    this.enable();\n  }\n\n  public on(event: DDDragEvent, callback: (event: DragEvent) => void): void {\n    super.on(event, callback);\n  }\n\n  public off(event: DDDragEvent): void {\n    super.off(event);\n  }\n\n  public enable(): void {\n    if (this.disabled === false) return;\n    super.enable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.addEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.addEventListener('touchstart', touchstart);\n        dragEl.addEventListener('pointerdown', pointerdown);\n        // dragEl.style.touchAction = 'none'; // not needed unlike pointerdown doc comment\n      }\n    });\n    this.el.classList.remove('ui-draggable-disabled');\n  }\n\n  public disable(forDestroy = false): void {\n    if (this.disabled === true) return;\n    super.disable();\n    this.dragEls.forEach(dragEl => {\n      dragEl.removeEventListener('mousedown', this._mouseDown);\n      if (isTouch) {\n        dragEl.removeEventListener('touchstart', touchstart);\n        dragEl.removeEventListener('pointerdown', pointerdown);\n      }\n    });\n    if (!forDestroy) this.el.classList.add('ui-draggable-disabled');\n  }\n\n  public destroy(): void {\n    if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n    delete this.dragTimeout;\n    if (this.mouseDownEvent) this._mouseUp(this.mouseDownEvent);\n    this.disable(true);\n    delete this.el;\n    delete this.helper;\n    delete this.option;\n    super.destroy();\n  }\n\n  public updateOption(opts: DDDraggableOpt): DDDraggable {\n    Object.keys(opts).forEach(key => this.option[key] = opts[key]);\n    return this;\n  }\n\n  /** @internal call when mouse goes down before a dragstart happens */\n  protected _mouseDown(e: MouseEvent): boolean {\n    // don't let more than one widget handle mouseStart\n    if (DDManager.mouseHandled) return;\n    if (e.button !== 0) return true; // only left click\n\n    // make sure we are not clicking on known object that handles mouseDown, or ones supplied by the user\n    if (!this.dragEls.find(el => el === e.target) && (e.target as HTMLElement).closest(skipMouseDown)) return true;\n    if (this.option.cancel) {\n      if ((e.target as HTMLElement).closest(this.option.cancel)) return true;\n    }\n\n    // REMOVE: why would we get the event if it wasn't for us or child ?\n    // make sure we are clicking on a drag handle or child of it...\n    // Note: we don't need to check that's handle is an immediate child, as mouseHandled will prevent parents from also handling it (lowest wins)\n    // let className = this.option.handle.substring(1);\n    // let el = e.target as HTMLElement;\n    // while (el && !el.classList.contains(className)) { el = el.parentElement; }\n    // if (!el) return;\n\n    this.mouseDownEvent = e;\n    delete this.dragging;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    // document handler so we can continue receiving moves as the item is 'fixed' position, and capture=true so WE get a first crack\n    document.addEventListener('mousemove', this._mouseMove, { capture: true, passive: true }); // true=capture, not bubble\n    document.addEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      e.target.addEventListener('touchmove', touchmove);\n      e.target.addEventListener('touchend', touchend);\n    }\n\n    e.preventDefault();\n    // preventDefault() prevents blur event which occurs just after mousedown event.\n    // if an editable content has focus, then blur must be call\n    if (document.activeElement) (document.activeElement as HTMLElement).blur();\n\n    DDManager.mouseHandled = true;\n    return true;\n  }\n\n  /** @internal method to call actual drag event */\n  protected _callDrag(e: DragEvent): void {\n    if (!this.dragging) return;\n    const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'drag' });\n    if (this.option.drag) {\n      this.option.drag(ev, this.ui());\n    }\n    this.triggerEvent('drag', ev);\n  }\n\n  /** @internal called when the main page (after successful mousedown) receives a move event to drag the item around the screen */\n  protected _mouseMove(e: DragEvent): boolean {\n    // console.log(`${count++} move ${e.x},${e.y}`)\n    let s = this.mouseDownEvent;\n    this.lastDrag = e;\n\n    if (this.dragging) {\n      this._dragFollow(e);\n      // delay actual grid handling drag until we pause for a while if set\n      if (DDManager.pauseDrag) {\n        const pause = Number.isInteger(DDManager.pauseDrag) ? DDManager.pauseDrag as number : 100;\n        if (this.dragTimeout) window.clearTimeout(this.dragTimeout);\n        this.dragTimeout = window.setTimeout(() => this._callDrag(e), pause);\n      } else {\n        this._callDrag(e);\n      }\n    } else if (Math.abs(e.x - s.x) + Math.abs(e.y - s.y) > 3) {\n      /**\n       * don't start unless we've moved at least 3 pixels\n       */\n      this.dragging = true;\n      DDManager.dragElement = this;\n      // if we're dragging an actual grid item, set the current drop as the grid (to detect enter/leave)\n      let grid = this.el.gridstackNode?.grid;\n      if (grid) {\n        DDManager.dropElement = (grid.el as DDElementHost).ddElement.ddDroppable;\n      } else {\n        delete DDManager.dropElement;\n      }\n      this.helper = this._createHelper(e);\n      this._setupHelperContainmentStyle();\n      this.dragTransform = Utils.getValuesFromTransformedElement(this.helperContainment);\n      this.dragOffset = this._getDragOffset(e, this.el, this.helperContainment);\n      this._setupHelperStyle(e);\n\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstart' });\n      if (this.option.start) {\n        this.option.start(ev, this.ui());\n      }\n      this.triggerEvent('dragstart', ev);\n      // now track keyboard events to cancel or rotate\n      document.addEventListener('keydown', this._keyEvent);\n    }\n    // e.preventDefault(); // passive = true. OLD: was needed otherwise we get text sweep text selection as we drag around\n    return true;\n  }\n\n  /** @internal call when the mouse gets released to drop the item at current location */\n  protected _mouseUp(e: MouseEvent): void {\n    document.removeEventListener('mousemove', this._mouseMove, true);\n    document.removeEventListener('mouseup', this._mouseUp, true);\n    if (isTouch) {\n      e.target.removeEventListener('touchmove', touchmove, true);\n      e.target.removeEventListener('touchend', touchend, true);\n    }\n    if (this.dragging) {\n      delete this.dragging;\n      delete (this.el.gridstackNode as GridStackNodeRotate)?._origRotate;\n      document.removeEventListener('keydown', this._keyEvent);\n\n      // reset the drop target if dragging over ourself (already parented, just moving during stop callback below)\n      if (DDManager.dropElement?.el === this.el.parentElement) {\n        delete DDManager.dropElement;\n      }\n\n      this.helperContainment.style.position = this.parentOriginStylePosition || null;\n      if (this.helper === this.el) {\n        this._removeHelperStyle();\n      } else {\n        this.helper.remove();\n      }\n      const ev = Utils.initEvent<DragEvent>(e, { target: this.el, type: 'dragstop' });\n      if (this.option.stop) {\n        this.option.stop(ev); // NOTE: destroy() will be called when removing item, so expect NULL ptr after!\n      }\n      this.triggerEvent('dragstop', ev);\n\n      // call the droppable method to receive the item\n      if (DDManager.dropElement) {\n        DDManager.dropElement.drop(e);\n      }\n    }\n    delete this.helper;\n    delete this.mouseDownEvent;\n    delete DDManager.dragElement;\n    delete DDManager.dropElement;\n    delete DDManager.mouseHandled;\n    e.preventDefault();\n  }\n\n  /** @internal call when keys are being pressed - use Esc to cancel, R to rotate */\n  protected _keyEvent(e: KeyboardEvent): void {\n    const n = this.el.gridstackNode as GridStackNodeRotate;\n    if (!n?.grid) return;\n    const grid = n.grid;\n\n    if (e.key === 'Escape') {\n      if (n._origRotate) {\n        n._orig = n._origRotate;\n        delete n._origRotate;\n      }\n      grid.engine.restoreInitial();\n      this._mouseUp(this.mouseDownEvent);\n    } else if (e.key === 'r' || e.key === 'R') {\n      if (!Utils.canBeRotated(n)) return;\n      n._origRotate = n._origRotate || { ...n._orig }; // store the real orig size in case we Esc after doing rotation\n      delete n._moving; // force rotate to happen (move waits for >50% coverage otherwise)\n      grid.setAnimation(false) // immediate rotate so _getDragOffset() gets the right dom size below\n        .rotate(n.el, { top: -this.dragOffset.offsetTop, left: -this.dragOffset.offsetLeft })\n        .setAnimation();\n      n._moving = true;\n      this.dragOffset = this._getDragOffset(this.lastDrag, n.el, this.helperContainment);\n      this.helper.style.width = this.dragOffset.width + 'px';\n      this.helper.style.height = this.dragOffset.height + 'px';\n      Utils.swap(n._orig, 'w', 'h');\n      delete n._rect;\n      this._mouseMove(this.lastDrag);\n    }\n  }\n\n  /** @internal create a clone copy (or user defined method) of the original drag item if set */\n  protected _createHelper(event: DragEvent): HTMLElement {\n    let helper = this.el;\n    if (typeof this.option.helper === 'function') {\n      helper = this.option.helper(event);\n    } else if (this.option.helper === 'clone') {\n      helper = Utils.cloneNode(this.el);\n    }\n    if (!document.body.contains(helper)) {\n      Utils.appendTo(helper, this.option.appendTo === 'parent' ? this.el.parentElement : this.option.appendTo);\n    }\n    if (helper === this.el) {\n      this.dragElementOriginStyle = DDDraggable.originStyleProp.map(prop => this.el.style[prop]);\n    }\n    return helper;\n  }\n\n  /** @internal set the fix position of the dragged item */\n  protected _setupHelperStyle(e: DragEvent): DDDraggable {\n    this.helper.classList.add('ui-draggable-dragging');\n    // TODO: set all at once with style.cssText += ... ? https://stackoverflow.com/questions/3968593\n    const style = this.helper.style;\n    style.pointerEvents = 'none'; // needed for over items to get enter/leave\n    // style.cursor = 'move'; //  TODO: can't set with pointerEvents=none ! (done in CSS as well)\n    style.width = this.dragOffset.width + 'px';\n    style.height = this.dragOffset.height + 'px';\n    style.willChange = 'left, top';\n    style.position = 'fixed'; // let us drag between grids by not clipping as parent .grid-stack is position: 'relative'\n    this._dragFollow(e); // now position it\n    style.transition = 'none'; // show up instantly\n    setTimeout(() => {\n      if (this.helper) {\n        style.transition = null; // recover animation\n      }\n    }, 0);\n    return this;\n  }\n\n  /** @internal restore back the original style before dragging */\n  protected _removeHelperStyle(): DDDraggable {\n    this.helper.classList.remove('ui-draggable-dragging');\n    let node = (this.helper as GridItemHTMLElement)?.gridstackNode;\n    // don't bother restoring styles if we're gonna remove anyway...\n    if (!node?._isAboutToRemove && this.dragElementOriginStyle) {\n      let helper = this.helper;\n      // don't animate, otherwise we animate offseted when switching back to 'absolute' from 'fixed'.\n      // TODO: this also removes resizing animation which doesn't have this issue, but others.\n      // Ideally both would animate ('move' would immediately restore 'absolute' and adjust coordinate to match,\n      // then trigger a delay (repaint) to restore to final dest with animate) but then we need to make sure 'resizestop'\n      // is called AFTER 'transitionend' event is received (see https://github.com/gridstack/gridstack.js/issues/2033)\n      let transition = this.dragElementOriginStyle['transition'] || null;\n      helper.style.transition = this.dragElementOriginStyle['transition'] = 'none'; // can't be NULL #1973\n      DDDraggable.originStyleProp.forEach(prop => helper.style[prop] = this.dragElementOriginStyle[prop] || null);\n      setTimeout(() => helper.style.transition = transition, 50); // recover animation from saved vars after a pause (0 isn't enough #1973)\n    }\n    delete this.dragElementOriginStyle;\n    return this;\n  }\n\n  /** @internal updates the top/left position to follow the mouse */\n  protected _dragFollow(e: DragEvent): void {\n    let containmentRect = { left: 0, top: 0 };\n    // if (this.helper.style.position === 'absolute') { // we use 'fixed'\n    //   const { left, top } = this.helperContainment.getBoundingClientRect();\n    //   containmentRect = { left, top };\n    // }\n    const style = this.helper.style;\n    const offset = this.dragOffset;\n    style.left = (e.clientX + offset.offsetLeft - containmentRect.left) * this.dragTransform.xScale + 'px';\n    style.top = (e.clientY + offset.offsetTop - containmentRect.top) * this.dragTransform.yScale + 'px';\n  }\n\n  /** @internal */\n  protected _setupHelperContainmentStyle(): DDDraggable {\n    this.helperContainment = this.helper.parentElement;\n    if (this.helper.style.position !== 'fixed') {\n      this.parentOriginStylePosition = this.helperContainment.style.position;\n      if (getComputedStyle(this.helperContainment).position.match(/static/)) {\n        this.helperContainment.style.position = 'relative';\n      }\n    }\n    return this;\n  }\n\n  /** @internal */\n  protected _getDragOffset(event: DragEvent, el: HTMLElement, parent: HTMLElement): DragOffset {\n\n    // in case ancestor has transform/perspective css properties that change the viewpoint\n    let xformOffsetX = 0;\n    let xformOffsetY = 0;\n    if (parent) {\n      xformOffsetX = this.dragTransform.xOffset;\n      xformOffsetY = this.dragTransform.yOffset;\n    }\n\n    const targetOffset = el.getBoundingClientRect();\n    return {\n      left: targetOffset.left,\n      top: targetOffset.top,\n      offsetLeft: - event.clientX + targetOffset.left - xformOffsetX,\n      offsetTop: - event.clientY + targetOffset.top - xformOffsetY,\n      width: targetOffset.width * this.dragTransform.xScale,\n      height: targetOffset.height * this.dragTransform.yScale\n    };\n  }\n\n  /** @internal TODO: set to public as called by DDDroppable! */\n  public ui(): DDUIData {\n    const containmentEl = this.el.parentElement;\n    const containmentRect = containmentEl.getBoundingClientRect();\n    const offset = this.helper.getBoundingClientRect();\n    return {\n      position: { //Current CSS position of the helper as { top, left } object\n        top: (offset.top - containmentRect.top) * this.dragTransform.yScale,\n        left: (offset.left - containmentRect.left) * this.dragTransform.xScale\n      }\n      /* not used by GridStack for now...\n      helper: [this.helper], //The object arr representing the helper that's being dragged.\n      offset: { top: offset.top, left: offset.left } // Current offset position of the helper as { top, left } object.\n      */\n    };\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}